3 + int_of_float 2.0;;
        OCaml version 4.02.3

# 1+2*3;;
- : int = 7
# 1.1 +. 2.2 *. 3.3;;
- : float = 8.36
# 7 mod 2;;
- : int = 1
# 3 + 2.0;;
Error: This expression has type float but an expression was expected of type
         int
# 3 +. 2.0;;
Error: This expression has type int but an expression was expected of type
         float
# 3 + int_of_float 2.0;;
- : int = 5
# true;;
- : bool = true
# false;;
- : bool = false
# 1 = 2;;
- : bool = false
# 1 <> 2 ;;
- : bool = true
# 1 <= 2;;
- : bool = true
# true && (false || not false);;
- : bool = true
# true && true;;
- : bool = true
# 'c';;
- : char = 'c'
# "objective" ^ "caml";;
- : string = "objectivecaml"
# ();;    
- : unit = ()
# ();
  ;
  
  ;;
Error: Syntax error
# 
  ;;
# #use "hello.ml"
  ;;
val hello : string = "hello"
val world : string = "world"
val helloworld : string = "hello world"
hello world
- : unit = ()
# 1 + true;;
Error: This expression has type bool but an expression was expected of type
         int
# let x = 1;;  
val x : int = 1
# let y = 2;
  ;
  ;;
Error: Syntax error
# let y = 2;;
val y : int = 2
# if x=y then x else y;;
- : int = 2
# fun x -> e;;
Error: Unbound value e
# fun x -> x+1;;
- : int -> int = <fun>
# c(2)
  ;;
Error: Unbound value c
# x(2)
  ;;
Error: This expression has type int
       This is not a function; it cannot be applied.
# x(2);;
Error: This expression has type int
       This is not a function; it cannot be applied.
# x
  ;;
- : int = 1
# fun x = "X";;
Error: Syntax error
# fun x -> "x";;
- : 'a -> string = <fun>
# fun y -> y*y;;
- : int -> int = <fun>
# y
  ;;
- : int = 2
# y;;
- : int = 2
# y 2;;
Error: This expression has type int
       This is not a function; it cannot be applied.
# y(2);
  ;;
Error: This expression has type int
       This is not a function; it cannot be applied.
# y(2);;
Error: This expression has type int
       This is not a function; it cannot be applied.
# fun x -> fun y -> x +y;;
- : int -> int -> int = <fun>
# fun x y -> x + y;;
- : int -> int -> int = <fun>
# fun x y z -> x + y + z ;;
- : int -> int -> int -> int = <fun>
# let f = fun x y -> x +y;;
val f : int -> int -> int = <fun>
# f 1 2;;
- : int = 3
# let g = f 1;;
val g : int -> int = <fun>
# g 2;;
- : int = 3
# exit 0;;  



*** length 
let rec length l =
if l =[] then 0
else 1+length(List.tl l);;



*** append 
let rec append l1 l2 =
match l1 with
| [] -> l2
| hd::tl -> hd::(append tl l2);; 


*** reverse
let rec reverse l =
match l with
| [] -> []
| hd::tl -> (reverse tl)@[hd];;

*** fast rev ?

*** nth
let rec nth l n =
match l with
| [] -> raise(Failure "XXXX")
| hd::tl -> if n = 0 then hd else nth tl (n-1);;


*** remove 1
let rec remove_first n l =
match l with
| [] -> []
| hd::tl -> if n = hd then tl else n::(remove_first n tl);;

*** remove 2 ???
let rec remove_first n l =
match l with
| [] -> []
| if n = List.hd then List.tl else List.hd::(remove_first n List.tl);; 

*** ex5 insert
let rec insert n l =
match l with
| [] -> [n]
| hd::tl -> if n < hd then n::hd::tl else hd::(insert n tl);;

*** ex6 sort
let rec sort l =
match l with 
| [] -> []
| hd::tl -> insert hd (sort tl);;

*** infinite loop
let rec f n = (print_int n; f (n+1));;

######## tail recursive

***** ex1 range 
try 1:
let rec range a b =
if a = b then [b] else a::(range a+1 b);;

sol:
let rec range a b =
if a > b then [] else a::(range (a+1) b);;

sol 2:
???

***** ex2 concat ???
[a;b] ??

let rec concat a b =
match a with
| [] -> b
| hd::tl -> hd::(concat tl b);;


***** ex3 zipper 
let rec zipper a b =
match a,b with
| [], [] -> []
| _ , [] -> a
| [],  _ -> b
| hd1::tl1, hd2::tl2 -> hd1::hd2::(zipper tl1 tl2);;

*** ex4 unzip
let rec unzip : ('a * 'b)list -> 'a list * 'b list
=fun l ->
match l with
| [] -> ([], [])
| (a,b)::tl -> let(l1,l2) = unzip tl in
(a::l1, b::l2);;

*** ex5 drop
let rec drop l n =
if n=0 then l else drop (List.tl l) (n-1);;


